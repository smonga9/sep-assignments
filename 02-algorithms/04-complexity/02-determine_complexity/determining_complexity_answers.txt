1. The Big-O of this algorithm is constant or O(1) as it will always take the same amount of time to complete regardless of N.
2. The Big-O of this algorithm is linear or O(n) based on the fact that it is dependent on the length of the collection and a larger collection would result in a corresponding increase in run time.
3. The Big-O of this algorithm is linear or O(n) based on the fact that it is dependent on the length of the collection and a larger collection would result in a corresponding increase in run time. This case provides a collection of collections but in the end it still remains as a linear Big-O because it is still dependent on the size of these collections and nothing more. A corresponding increase in collection size will have a resultant and predictable increase in run-time.
4. The Big-O of this algorithm is O(2^N) based on the fact that it recursively runs through itself repeatedly the larger it gets. With each increase in N it has to run through itself for the prior number and the number prior to that repeatedly until N reaches back to 1 or 0. This as a result causes the algorithm to grow exponentially as N increases.
5. The Big-O of this algorithm is linear or O(n) based on the fact that it is only dependent on the size of N. As N increases the number of times that it runs through is increased by a constant amount.
6. The Big-O of this algorithm is O(N^2). It recursively runs through itself repeatedly until completion and is dependent on the size of the collection, but on top of that it is clear that this is an implementation of quick sort and therefore can be confirmed as a Big-O of O(N^2).
